Тестовые данные:
random - Перемешанный массив, значения от 0 до N-1
digits - Перемешаный массив, значений от 0 до 9
sorted - Почти отсортированный массив, значения от 0 до N-1
revers - Обратно отсортированный массив, значения от 0 до N-1

Размер массива зависит от теста:
0. 1
1. 10
...
6. 1,000,000
7. 10,000,000

Подробные таблицы времени продождения тестов находятся в файлах с кодом самих сортировок.
Первые два алгоритма элементарны, вторые "сам бы никогда не придумал", так что последние скопировал из лекции, а вникал как они работают уже после.
Это сильно сократило время работы над домашкой.

BubbleSort.
Беспощадно долго, не все тесты прошел.
 * random, digits - Уже 5ый тест из 100к элементов выполнялся 15сек, 1кк элементов выполнялся бы минут 25.
 * sorted - отсортировался значительно быстрее, за счет меньшего количества перестановок: 100к за 4.5 сек, 1кк за 8 минут.
 * revers - внезапно тоже отсортировался быстрее, 100к за 6.5сек.

SelectionSort.
upd. в реализации была ошибка и первональные замеры и выводы были ошибочные.
Значительно быстрее чем бабл и работает работает примерно с одинаковой скоростью для разных данных.
 * random, digits, sorted, revers - 100к за 3.6 сек

InsertionSort. (добавлен позже)
Быстрее чем SelectionSort, но сильная сторона алгоритма в том, что он очень быстрый на sorted данных.
Почему-то я проигнорировал эту адаптиность и даже в первый раз не реализовывал алгоритм, потому что он показался тем же баблом только в профиль.
Но потом наткнулся на то, что он используется внутри тимсорт (за счет адаптивности) и решил все-таки реализовать.
 * random, digits - 100к элементов выполнялся 2.2сек, digits процентов на 10% быстрее
 * sorted - 100к элементов сортировал 0.090 сек, а 1млн за 6.5 сек. Это первый алгоритм который прошел 6ой тест за считанные секунды
 * revers - в 2 раза медленее рандома, 100к за 4.4сек.

ShellSort.
Первая сортировка которая удивила (upd. нет, потом добавил InsertionSort, он удивил адаптивностью), он сразу почти
моментально прошел первые 6 тестов и 7ой(10кк элементов) прошел за меньше чем 7сек.
 * random - 10кк за 6.8сек, 1кк за 0.5 секунд! ПОЛОВИНА СЕКУНДЫ, пузырек бы в лучшем случае такое полчаса пыхтел.
 * digits - 10кк за 2 секунды! Алгоритмы, чтож вы делаете!
 * sorted - примерно как рандом, но чуть лушче. 10кк за 5.8
 * revers - тут что-то среднее между рандомом и цифрами. 1кк за 4.4сек

Шелсорт первый кто удивил, когда за секунду он прошел 6 тестов, я сначала не поверил и пошел перепроверять действтительно ли тесты проходят.
Такой большой был шок. В результатах еще интересно, что рандом отсортировался за 6.8сек, цифры за 2, а реверс за среднее от этих двух!
Интересно, может тут какой-то скрытый смысл, но может просто совпадение.

Еще шел удивил, когда начал экспериментировать с gap: (все время указывается для 10кк и random)
- Если делить на 3, то 7 тест (только он) валится с ошибкой. Но выполнился чуть быстрее, время 6.4сек.
- Если делить на 4, то половина тестов валится с ошибкой, время 6.2 сек.
- Если делить на 10, то тесты все ОК, но время значительно медленее, 44 секунды!
- Если делить на 1.5, тесты ОК, время 6.1 сек, первый более быстрый результат чем оригинальный!
- Если делить на 1.8, тесты ОК, время 5.9 сек меньше 6 секунд!
- Если делить на 1.5 и с каждой итерацией внешнего массива увеличивать на 0.5, то результат 6 секунд, а коэфициент в конца уже 2.5
- Если делить на 2 и с каждой итерацией внешнего массива увеличивать на 0.5, то результат 5.7 секунд! Но тесты иногда опять валятся :(
- Если делить на 2 и с каждой итерацией внешнего массива умножать на 1.1, то результат 5.5 секунд! Но тесты валятся в половине случаев :((
Понял почему иногда тесты валятся. Должно быть последняя итерация, когда gap должен быть 1, он не наступает, а проскакивает сразу в 0. Наверняка можно побороть, но уже устал, потом на википедии почитаю.

HeapSort.
 * random - 10кк за 9.3сек, медленнее чем ShellSort
 * digits - 10кк за 3.2сек, опять медленнее чем ShellSort
 * sorted, revers - 10кк за 6.3сек, ииии опять медленнее чем ShellSort
