Тестовые данные:
random - Перемешанный массив, значения от 0 до N-1
digits - Перемешаный массив, значений от 0 до 9
sorted - Почти отсортированный массив, значения от 0 до N-1
revers - Обратно отсортированный массив, значения от 0 до N-1

Размер массива зависит от теста:
0. 1
1. 10
...
6. 1,000,000
7. 10,000,000

Подробные таблицы времени продождения тестов находятся в файлах с кодом самих сортировок.
Первые два алгоритма элементарны, вторые "сам бы никогда не придумал", так что последние скопировал из лекции, а вникал как они работают уже после.
Это сильно сократило время работы над домашкой.

BubbleSort.
Беспощадно долго, не все тесты прошел.
 * random, digits - Уже 5ый тест из 100к элементов выполнялся 15сек, 1кк элементов выполнялся бы минут 25.
 * sorted - отсортировался значительно быстрее, за счет меньшего количества перестановок: 100к за 4.5 сек, 1кк за 8 минут.
 * revers - внезапно тоже отсортировался быстрее, 100к за 6.5сек.

SelectionSort.
 * random - по времени точная копия пузырька, дальше интеренее.
 * digits, sorted - тут уже такая же скорость, как у пузырька в sorted. 100к за 4.5 сек
 * revers - чуть медленнее 100к за 5.8сек
Если честно, не понял почему такая разная скорость в разных тестах, уже начал сомневаться о своем предположении о sorted в бабле.

ShellSort.
Первый массив который удивил, он сразу почти моментально прошел первые 6 тестов и 7ой(10кк элементов) прошел за меньше чем 7сек.
 * random - 10кк за 6.8сек, 1кк за 0.5 секунд! ПОЛОВИНА СЕКУНДЫ, пузырек бы в лучшем случае такое полчаса пыхтел.
 * digits - 10кк за 2 секунды! Алгоритмы, чтож вы делаете!
 * sorted - примерно как рандом, но чуть лушче. 10кк за 5.8
 * revers - тут что-то среднее между рандомом и цифрами. 1кк за 4.4сек

Шелсорт первый кто удивил, когда за секунду он прошел 6 тестов, я сначала не поверил и пошел перепроверять действтительно ли тесты проходят.
Такой большой был шок. В результатах еще интересно, что рандом отсортировался за 6.8сек, цифры за 2, а реверс за среднее от этих двух!
Интересно, может тут какой-то скрытый смысл, но может просто совпадение.

Еще шел удивил, когда начал экспериментировать с gap: (все время указывается для 10кк и random)
- Если делить на 3, то 7 тест (только он) валится с ошибкой. Но выполнился чуть быстрее, время 6.4сек.
- Если делить на 4, то половина тестов валится с ошибкой, время 6.2 сек.
- Если делить на 10, то тесты все ОК, но время значительно медленее, 44 секунды!
- Если делить на 1.5, тесты ОК, время 6.1 сек, первый более быстрый результат чем оригинальный!
- Если делить на 1.8, тесты ОК, время 5.9 сек меньше 6 секунд!
- Если делить на 1.5 и с каждой итерацией внешнего массива увеличивать на 0.5, то результат 6 секунд, а коэфициент в конца уже 2.5
- Если делить на 2 и с каждой итерацией внешнего массива увеличивать на 0.5, то результат 5.7 секунд! Но тесты иногда опять валятся :(
- Если делить на 2 и с каждой итерацией внешнего массива умножать на 1.1, то результат 5.5 секунд! Но тесты валятся в половине случаев :((
- Понял почему иногда тесты валятся. Должно быть последняя итерация, когда gap должен быть 1, он не наступает, а проскакивает сразу в 0. Наверняка можно побороть, но уже устал, потом на википедии почитаю.

HeapSort.
 * random - 10кк за 9.3сек, медленнее чем ShellSort
 * digits - 10кк за 3.2сек, опять медленнее чем ShellSort
 * sorted, revers - 10кк за 6.3сек, ииии опять медленнее чем ShellSort
